# CLAUDE.md

## Project Overview

This is a web-based remote control interface for Reaper DAW (Digital Audio Workstation). It provides a clean, responsive UI for controlling basic transport and project management functions in Reaper through a web browser.

## Architecture

### Technology Stack
- **Frontend**: Lit web components framework (v3.3+), TypeScript, HTML5, CSS3
- **Build Tool**: Vite for development and production builds
- **Package Manager**: pnpm for dependency management
- **Communication**: Reaper's built-in HTTP web interface
- **Deployment**: Built files served from Reaper's `reaper_www_root` directory

### File Structure
```
reaper-ui/
├── src/
│   ├── components/
│   │   ├── reaper-remote.ts    # Main app component
│   │   └── control-button.ts   # Reusable button component
│   ├── services/
│   │   └── reaper-api.ts        # Reaper API communication service
│   ├── types/
│   │   └── index.ts             # TypeScript types and interfaces
│   ├── styles/
│   │   └── shared.ts            # Shared CSS styles
│   └── style.css                # Global CSS with custom properties
├── index.html                   # Main HTML entry point
├── tsconfig.json                # TypeScript configuration
├── vite.config.js               # Vite build configuration
├── package.json                 # Project dependencies and scripts
├── pnpm-lock.yaml               # pnpm lock file
├── dist/                        # Built files (generated by Vite)
└── CLAUDE.md                    # Project documentation
```

## How It Works

### Communication with Reaper

The interface communicates with Reaper using HTTP GET requests to Reaper's web interface endpoint through the `ReaperAPI` service:

```typescript
// src/services/reaper-api.ts
await reaperAPI.sendCommand(action);
```

Internally, this sends:
```typescript
fetch(`/_/${commandId}`, { method: 'GET' })
```

When files are served from Reaper's `reaper_www_root` directory, the relative URL `/_/` automatically resolves to Reaper's command endpoint.

### Command Mapping

Each control button maps to a specific Reaper action ID:

| Button       | Command ID | Reaper Action                    |
|--------------|------------|----------------------------------|
| Record       | 1013       | Transport: Record                |
| Abort        | 40668      | Transport: Stop (abort)          |
| Play         | 1007       | Transport: Play                  |
| Pause        | 1008       | Transport: Pause                 |
| Stop         | 1016       | Transport: Stop                  |
| Save         | 42230      | File: Save project               |
| Clear All    | -          | Composite: Select All + Delete + Go to Start |
| Select All   | 40182      | Item: Select all items           |
| Delete       | 40006      | Item: Remove items               |
| Go to Start  | 40042      | View: Go to start of project     |

**Note**: The "Clear All" button is a composite action that executes three commands in sequence via `sendMultipleCommands()`.

### UI State Management & Component Architecture

The application uses a modular component-based architecture with real-time state synchronization:

**ReaperRemote** (Main Component):
- Uses `@state` decorator for internal state (playActive, pauseActive, recordActive)
- Polls Reaper's transport state every 200ms to stay synchronized
- Handles command execution through the `ReaperAPI` service
- Manages user confirmations for destructive actions
- Delegates rendering to child `ControlButton` components
- Implements lifecycle methods (`connectedCallback`, `disconnectedCallback`) for polling management

**ControlButton** (Reusable Component):
- Accepts configuration via properties (action, label, title, icon, variant)
- Emits custom events (`button-click`) for parent handling
- Uses `classMap` directive for clean conditional class handling
- Encapsulates button-specific styling and behavior
- Uniform button sizing via `aspect-ratio: 1` and `min-height: 120px`

**Service Layer**:
- `ReaperAPI` singleton handles all Reaper communication
- Provides `sendCommand()` for executing single actions
- Provides `sendMultipleCommands()` for executing multiple actions in sequence (used by "Clear All")
- Provides `getTransportState()` for querying transport state via `/_/TRANSPORT`
- Provides `getCommandState()` for querying individual action states via `/_/GET/{commandId}`
- Separates business logic from UI components
- Provides centralized error handling

**State Synchronization**:
The UI polls Reaper's transport state every 200ms, mapping playstate values:
- 0 = Stopped
- 1 = Playing
- 2 = Paused
- 5 = Recording
- 6 = Record paused

This ensures the UI accurately reflects Reaper's state even when controls are triggered directly in Reaper. Lit's reactive properties (`@state`) automatically update the UI when state changes.

## Design Decisions

### TypeScript & Lit Web Components
- **TypeScript**: Full type safety with interfaces, types, and decorators
- **Lit Decorators**:
  - `@customElement` for component registration
  - `@property` for public reactive properties
  - `@state` for internal reactive state
- **Component Architecture**: Modular, reusable components with clear separation of concerns
- **Lit Directives**:
  - `classMap` for dynamic CSS classes
  - `unsafeHTML` for rendering SVG icons
- **Event System**: Custom events for component communication
- **Shadow DOM**: Encapsulated styling and markup
- **Service Layer**: Separation of API logic from UI components
- **Small bundle size**: ~5KB gzipped for Lit core

### Modern Build Tooling
- Vite for fast development server with Hot Module Replacement (HMR)
- Optimized production builds with code splitting
- ES modules support for modern JavaScript
- Simple configuration with minimal setup

### CSS Custom Properties
All colors, spacing, and transitions are defined as CSS variables in `:root`, making it trivial to customize the theme without touching the core styles. Component-specific styles are encapsulated within the Lit component's `static styles`.

### Responsive Grid Layout
The control buttons use CSS Grid with a 3-column layout on desktop, 2-column layout on tablet/mobile (≤768px), with optimized spacing on smaller screens (≤480px). Buttons maintain uniform sizing via `aspect-ratio: 1` for a clean, consistent appearance.

### Relative URLs
Using relative URLs (`/_/`) instead of absolute URLs means the interface works regardless of:
- The port Reaper is running on
- Whether accessed via localhost or network IP
- Which subdirectory the files are placed in

## Key Features

1. **Real-time State Synchronization**: Polls Reaper every 200ms to reflect actual transport state
2. **Time Display**: Shows current playback position from Reaper
3. **Composite Actions**: "Clear All" button executes multiple commands in sequence
4. **Reactive UI**: Lit's reactive properties automatically update the interface
5. **Responsive Design**: Optimized for desktop (3-column), tablet, and mobile devices (2-column)
   - Desktop: 100px buttons with 28px icons
   - Mobile (≤480px): 70px buttons with 20px icons and reduced padding
6. **Uniform Button Sizing**: All buttons maintain consistent square aspect ratio
7. **Visual Feedback**: Active states for play/pause/record with animations and color coding
8. **No Confirmation Dialogs**: All actions execute immediately for streamlined workflow
9. **Easy Theming**: CSS custom properties for quick customization
10. **Fast Development**: Vite dev server with instant HMR
11. **Optimized Builds**: Production-ready bundles for deployment

## Extending the Interface

### Adding New Controls

1. **Update types** in `src/types/index.ts`:
```typescript
export type CommandAction = 'play' | 'pause' | 'stop' | 'record' | 'save' | 'discard' | 'new';

export const REAPER_COMMANDS: Record<CommandAction, number> = {
    // ... existing commands
    new: 12345  // Replace with actual Reaper command ID
};
```

2. **Add state** in `src/components/reaper-remote.ts` (if stateful):
```typescript
@state()
private newActive = false;
```

3. **Add button** in the `render()` method:
```typescript
<control-button
    action="new"
    label="New Action"
    title="New Action"
    .active=${this.newActive}
    icon='<svg>...</svg>'>
</control-button>
```

Note: State is now automatically synchronized via polling, so manual state updates are no longer needed. The polling mechanism in `updateStateFromReaper()` handles all state updates based on Reaper's transport state.

### Creating New Components

Follow the `ControlButton` pattern:

1. Create file in `src/components/`
2. Use `@customElement` decorator
3. Define typed `@property` decorators for public API
4. Use `@state` for internal state
5. Import shared styles from `src/styles/shared.ts`
6. Emit custom events for parent communication
7. Add TypeScript declaration for global registry

### Finding Reaper Command IDs

1. Open Reaper
2. Go to **Actions** → **Show action list**
3. Search for the action you want
4. The command ID is shown in the **Command ID** column

### Customizing Appearance

Edit the CSS custom properties in `style.css`:
```css
:root {
    --primary-bg: #1a1a1a;
    --accent-color: #4a9eff;
    /* ... etc */
}
```

## Limitations

- **No Beat/Measure Display**: Only shows time position, not beat/measure position (though data is available)
- **Polling Overhead**: 200ms polling interval creates continuous network traffic
- **Development Mode**: State polling fails gracefully when running on Vite dev server (only works when served from Reaper)
- **No Undo for Composite Actions**: "Clear All" executes three separate commands without undo grouping

## Future Enhancement Ideas

- Add beat/measure position display alongside time display
- Include volume/pan controls for tracks
- Add project/track selection
- Implement keyboard shortcuts
- Optimize polling (e.g., use WebSocket for real-time updates instead of polling)
- Include marker navigation
- Add FX parameter controls
- Add configurable poll interval
- Implement connection status indicator
- Add undo grouping for composite actions
- Add render button with recent settings
- Include loop/repeat controls

## Development Notes

### Development Workflow

1. **Install dependencies**:
```bash
pnpm install
```

2. **Run development server** (with HMR):
```bash
pnpm run dev
```

3. **Build for production**:
```bash
pnpm run build
```

4. **Preview production build**:
```bash
pnpm run preview
```

### Deployment to Reaper

After building for production:
1. Copy files from `dist/` directory to Reaper's `reaper_www_root` directory
2. Ensure Reaper has web interface enabled (Preferences → Control/OSC/web)
3. Access via `http://localhost:8080/` (or your configured port)

### Browser Compatibility
Uses modern TypeScript/JavaScript features:
- TypeScript with decorators (`experimentalDecorators`)
- ES2022 features (ES modules, classes, arrow functions, template literals)
- Lit directives and templating
- Fetch API
- Web Components (Custom Elements, Shadow DOM)
- CSS custom properties

TypeScript is compiled to JavaScript by Vite during the build process. All features are supported in modern browsers (Chrome/Edge/Firefox/Safari). Internet Explorer is not supported.

## Architecture Benefits

The refactored architecture provides:

1. **Type Safety**: TypeScript catches errors at compile time
2. **Modularity**: Each component/service has a single responsibility
3. **Reusability**: `ControlButton` can be reused for any new controls
4. **Maintainability**: Clear separation between UI, state, and API logic
5. **Testability**: Services and components can be tested independently
6. **Scalability**: Easy to add new features without modifying existing code
7. **Developer Experience**: IntelliSense, auto-completion, and type checking

## Development Rules

### Testing Changes
**IMPORTANT**: Whenever you make changes to the codebase, you MUST verify them using Chrome DevTools MCP:

1. Ensure the dev server is running (`pnpm run dev`)
2. Navigate to the application in Chrome DevTools MCP
3. Take a snapshot to verify UI elements are present
4. Check console messages for errors
5. Test relevant functionality by clicking buttons/interacting with UI
6. Verify network requests are being sent correctly
7. Take screenshots to confirm visual changes

This ensures all changes are working correctly in the browser before considering the task complete.
