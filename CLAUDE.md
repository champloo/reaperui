# CLAUDE.md

## Project Overview

This is a web-based remote control interface for Reaper DAW (Digital Audio Workstation). It provides a clean, responsive UI for controlling basic transport and project management functions in Reaper through a web browser.

## Architecture

### Technology Stack
- **Frontend**: Lit web components framework (v3.3+), TypeScript, HTML5, CSS3
- **Build Tool**: Vite for development and production builds
- **Package Manager**: pnpm for dependency management
- **Communication**: Reaper's built-in HTTP web interface
- **Deployment**: Built files served from Reaper's `reaper_www_root` directory

### File Structure
```
reaper-ui/
├── src/
│   ├── components/
│   │   ├── reaper-remote.ts    # Main app component
│   │   └── control-button.ts   # Reusable button component
│   ├── services/
│   │   └── reaper-api.ts        # Reaper API communication service
│   ├── types/
│   │   └── index.ts             # TypeScript types and interfaces
│   ├── styles/
│   │   └── shared.ts            # Shared CSS styles
│   └── style.css                # Global CSS with custom properties
├── index.html                   # Main HTML entry point
├── tsconfig.json                # TypeScript configuration
├── vite.config.js               # Vite build configuration
├── package.json                 # Project dependencies and scripts
├── pnpm-lock.yaml               # pnpm lock file
├── dist/                        # Built files (generated by Vite)
└── CLAUDE.md                    # Project documentation
```

## How It Works

### Communication with Reaper

The interface communicates with Reaper using HTTP GET requests to Reaper's web interface endpoint through the `ReaperAPI` service:

```typescript
// src/services/reaper-api.ts
await reaperAPI.sendCommand(action);
```

Internally, this sends:
```typescript
fetch(`/_/${commandId}`, { method: 'GET' })
```

When files are served from Reaper's `reaper_www_root` directory, the relative URL `/_/` automatically resolves to Reaper's command endpoint.

### Command Mapping

Each control button maps to a specific Reaper action ID:

| Button   | Command ID | Reaper Action           |
|----------|------------|-------------------------|
| Play     | 1007       | Transport: Play         |
| Pause    | 1008       | Transport: Pause        |
| Stop     | 1016       | Transport: Stop         |
| Record   | 1013       | Transport: Record       |
| Save     | 40026      | File: Save project      |
| Discard  | 40029      | Edit: Undo              |

### UI State Management & Component Architecture

The application uses a modular component-based architecture with real-time state synchronization:

**ReaperRemote** (Main Component):
- Uses `@state` decorator for internal state (playActive, pauseActive, recordActive)
- Polls Reaper's transport state every 200ms to stay synchronized
- Handles command execution through the `ReaperAPI` service
- Manages user confirmations for destructive actions
- Delegates rendering to child `ControlButton` components
- Implements lifecycle methods (`connectedCallback`, `disconnectedCallback`) for polling management

**ControlButton** (Reusable Component):
- Accepts configuration via properties (action, label, title, icon, variant)
- Emits custom events (`button-click`) for parent handling
- Uses `classMap` directive for clean conditional class handling
- Encapsulates button-specific styling and behavior
- Uniform button sizing via `aspect-ratio: 1` and `min-height: 120px`

**Service Layer**:
- `ReaperAPI` singleton handles all Reaper communication
- Provides `sendCommand()` for executing actions
- Provides `getTransportState()` for querying transport state via `/_/TRANSPORT`
- Provides `getCommandState()` for querying individual action states via `/_/GET/{commandId}`
- Separates business logic from UI components
- Provides centralized error handling

**State Synchronization**:
The UI polls Reaper's transport state every 200ms, mapping playstate values:
- 0 = Stopped
- 1 = Playing
- 2 = Paused
- 5 = Recording
- 6 = Record paused

This ensures the UI accurately reflects Reaper's state even when controls are triggered directly in Reaper. Lit's reactive properties (`@state`) automatically update the UI when state changes.

## Design Decisions

### TypeScript & Lit Web Components
- **TypeScript**: Full type safety with interfaces, types, and decorators
- **Lit Decorators**:
  - `@customElement` for component registration
  - `@property` for public reactive properties
  - `@state` for internal reactive state
- **Component Architecture**: Modular, reusable components with clear separation of concerns
- **Lit Directives**:
  - `classMap` for dynamic CSS classes
  - `unsafeHTML` for rendering SVG icons
- **Event System**: Custom events for component communication
- **Shadow DOM**: Encapsulated styling and markup
- **Service Layer**: Separation of API logic from UI components
- **Small bundle size**: ~5KB gzipped for Lit core

### Modern Build Tooling
- Vite for fast development server with Hot Module Replacement (HMR)
- Optimized production builds with code splitting
- ES modules support for modern JavaScript
- Simple configuration with minimal setup

### CSS Custom Properties
All colors, spacing, and transitions are defined as CSS variables in `:root`, making it trivial to customize the theme without touching the core styles. Component-specific styles are encapsulated within the Lit component's `static styles`.

### Responsive Grid Layout
The control buttons use CSS Grid with a 3-column layout on desktop, 2-column layout on tablet/mobile (≤768px), with optimized spacing on smaller screens (≤480px). Buttons maintain uniform sizing via `aspect-ratio: 1` for a clean, consistent appearance.

### Relative URLs
Using relative URLs (`/_/`) instead of absolute URLs means the interface works regardless of:
- The port Reaper is running on
- Whether accessed via localhost or network IP
- Which subdirectory the files are placed in

## Key Features

1. **Real-time State Synchronization**: Polls Reaper every 200ms to reflect actual transport state
2. **Reactive UI**: Lit's reactive properties automatically update the interface
3. **Responsive Design**: Works on desktop (3-column), tablet, and mobile devices (2-column)
4. **Uniform Button Sizing**: All buttons maintain consistent size regardless of content
5. **Visual Feedback**: Active states for play/pause/record with animations
6. **Confirmation Dialogs**: Prevents accidental undo operations
7. **Easy Theming**: CSS custom properties for quick customization
8. **Fast Development**: Vite dev server with instant HMR
9. **Optimized Builds**: Production-ready bundles for deployment

## Extending the Interface

### Adding New Controls

1. **Update types** in `src/types/index.ts`:
```typescript
export type CommandAction = 'play' | 'pause' | 'stop' | 'record' | 'save' | 'discard' | 'new';

export const REAPER_COMMANDS: Record<CommandAction, number> = {
    // ... existing commands
    new: 12345  // Replace with actual Reaper command ID
};
```

2. **Add state** in `src/components/reaper-remote.ts` (if stateful):
```typescript
@state()
private newActive = false;
```

3. **Add button** in the `render()` method:
```typescript
<control-button
    action="new"
    label="New Action"
    title="New Action"
    .active=${this.newActive}
    icon='<svg>...</svg>'>
</control-button>
```

Note: State is now automatically synchronized via polling, so manual state updates are no longer needed. The polling mechanism in `updateStateFromReaper()` handles all state updates based on Reaper's transport state.

### Creating New Components

Follow the `ControlButton` pattern:

1. Create file in `src/components/`
2. Use `@customElement` decorator
3. Define typed `@property` decorators for public API
4. Use `@state` for internal state
5. Import shared styles from `src/styles/shared.ts`
6. Emit custom events for parent communication
7. Add TypeScript declaration for global registry

### Finding Reaper Command IDs

1. Open Reaper
2. Go to **Actions** → **Show action list**
3. Search for the action you want
4. The command ID is shown in the **Command ID** column

### Customizing Appearance

Edit the CSS custom properties in `style.css`:
```css
:root {
    --primary-bg: #1a1a1a;
    --accent-color: #4a9eff;
    /* ... etc */
}
```

## Limitations

- **No Transport Position Display**: Doesn't display current playback position or time (data is available via polling but not shown in UI)
- **Basic Controls Only**: Limited to the six implemented transport/project controls
- **Polling Overhead**: 200ms polling interval creates continuous network traffic
- **Development Mode**: State polling fails gracefully when running on Vite dev server (only works when served from Reaper)

## Future Enhancement Ideas

- Display transport position/time (data already available from polling)
- Include volume/pan controls for tracks
- Add project/track selection
- Implement keyboard shortcuts
- Optimize polling (e.g., use WebSocket for real-time updates instead of polling)
- Include marker navigation
- Add FX parameter controls
- Add configurable poll interval
- Implement connection status indicator

## Development Notes

### Development Workflow

1. **Install dependencies**:
```bash
pnpm install
```

2. **Run development server** (with HMR):
```bash
pnpm run dev
```

3. **Build for production**:
```bash
pnpm run build
```

4. **Preview production build**:
```bash
pnpm run preview
```

### Deployment to Reaper

After building for production:
1. Copy files from `dist/` directory to Reaper's `reaper_www_root` directory
2. Ensure Reaper has web interface enabled (Preferences → Control/OSC/web)
3. Access via `http://localhost:8080/` (or your configured port)

### Browser Compatibility
Uses modern TypeScript/JavaScript features:
- TypeScript with decorators (`experimentalDecorators`)
- ES2022 features (ES modules, classes, arrow functions, template literals)
- Lit directives and templating
- Fetch API
- Web Components (Custom Elements, Shadow DOM)
- CSS custom properties

TypeScript is compiled to JavaScript by Vite during the build process. All features are supported in modern browsers (Chrome/Edge/Firefox/Safari). Internet Explorer is not supported.

## Architecture Benefits

The refactored architecture provides:

1. **Type Safety**: TypeScript catches errors at compile time
2. **Modularity**: Each component/service has a single responsibility
3. **Reusability**: `ControlButton` can be reused for any new controls
4. **Maintainability**: Clear separation between UI, state, and API logic
5. **Testability**: Services and components can be tested independently
6. **Scalability**: Easy to add new features without modifying existing code
7. **Developer Experience**: IntelliSense, auto-completion, and type checking

## Development Rules

### Testing Changes
**IMPORTANT**: Whenever you make changes to the codebase, you MUST verify them using Chrome DevTools MCP:

1. Ensure the dev server is running (`pnpm run dev`)
2. Navigate to the application in Chrome DevTools MCP
3. Take a snapshot to verify UI elements are present
4. Check console messages for errors
5. Test relevant functionality by clicking buttons/interacting with UI
6. Verify network requests are being sent correctly
7. Take screenshots to confirm visual changes

This ensures all changes are working correctly in the browser before considering the task complete.
