# CLAUDE.md

## Project Overview

This is a web-based remote control interface for Reaper DAW (Digital Audio Workstation). It provides a clean, responsive UI for controlling basic transport and project management functions in Reaper through a web browser.

## Architecture

### Technology Stack
- **Frontend**: Lit web components framework (v3.3+), TypeScript, HTML5, CSS3
- **Build Tool**: Vite for development and production builds
- **Package Manager**: pnpm for dependency management
- **Communication**: Reaper's built-in HTTP web interface
- **Deployment**: Built files served from Reaper's `reaper_www_root` directory

### File Structure
```
reaper-ui/
├── src/
│   ├── components/
│   │   ├── reaper-remote.ts    # Main app component
│   │   └── control-button.ts   # Reusable button component
│   ├── services/
│   │   └── reaper-api.ts        # Reaper API communication service
│   ├── types/
│   │   └── index.ts             # TypeScript types and interfaces
│   ├── styles/
│   │   └── shared.ts            # Shared CSS styles
│   └── style.css                # Global CSS with custom properties
├── index.html                   # Main HTML entry point
├── tsconfig.json                # TypeScript configuration
├── vite.config.js               # Vite build configuration
├── package.json                 # Project dependencies and scripts
├── pnpm-lock.yaml               # pnpm lock file
├── dist/                        # Built files (generated by Vite)
└── CLAUDE.md                    # Project documentation
```

## How It Works

### Communication with Reaper

The interface communicates with Reaper using HTTP GET requests to Reaper's web interface endpoint through the `ReaperAPI` service:

```typescript
// src/services/reaper-api.ts
await reaperAPI.sendCommand(action);
```

Internally, this sends:
```typescript
fetch(`/_/${commandId}`, { method: 'GET' })
```

When files are served from Reaper's `reaper_www_root` directory, the relative URL `/_/` automatically resolves to Reaper's command endpoint.

### Command Mapping

Each control button maps to a specific Reaper action ID:

| Button   | Command ID | Reaper Action           |
|----------|------------|-------------------------|
| Play     | 1007       | Transport: Play         |
| Pause    | 1008       | Transport: Pause        |
| Stop     | 1016       | Transport: Stop         |
| Record   | 1013       | Transport: Record       |
| Save     | 40026      | File: Save project      |
| Discard  | 40029      | Edit: Undo              |

### UI State Management & Component Architecture

The application uses a modular component-based architecture:

**ReaperRemote** (Main Component):
- Uses `@state` decorator for internal state (playActive, pauseActive, recordActive)
- Handles command execution through the `ReaperAPI` service
- Manages user confirmations for destructive actions
- Delegates rendering to child `ControlButton` components

**ControlButton** (Reusable Component):
- Accepts configuration via properties (action, label, title, icon, variant)
- Emits custom events (`button-click`) for parent handling
- Uses `classMap` directive for clean conditional class handling
- Encapsulates button-specific styling and behavior

**Service Layer**:
- `ReaperAPI` singleton handles all Reaper communication
- Separates business logic from UI components
- Provides centralized error handling

Button states are purely client-side and provide immediate visual feedback without waiting for Reaper's response. Lit's reactive properties (`@state`) automatically update the UI when state changes.

## Design Decisions

### TypeScript & Lit Web Components
- **TypeScript**: Full type safety with interfaces, types, and decorators
- **Lit Decorators**:
  - `@customElement` for component registration
  - `@property` for public reactive properties
  - `@state` for internal reactive state
- **Component Architecture**: Modular, reusable components with clear separation of concerns
- **Lit Directives**:
  - `classMap` for dynamic CSS classes
  - `unsafeHTML` for rendering SVG icons
- **Event System**: Custom events for component communication
- **Shadow DOM**: Encapsulated styling and markup
- **Service Layer**: Separation of API logic from UI components
- **Small bundle size**: ~5KB gzipped for Lit core

### Modern Build Tooling
- Vite for fast development server with Hot Module Replacement (HMR)
- Optimized production builds with code splitting
- ES modules support for modern JavaScript
- Simple configuration with minimal setup

### CSS Custom Properties
All colors, spacing, and transitions are defined as CSS variables in `:root`, making it trivial to customize the theme without touching the core styles. Component-specific styles are encapsulated within the Lit component's `static styles`.

### Responsive Grid Layout
The control buttons use CSS Grid with `auto-fit` and `minmax()` for automatic responsive behavior across devices without media queries (media queries only adjust grid columns at breakpoints).

### Relative URLs
Using relative URLs (`/_/`) instead of absolute URLs means the interface works regardless of:
- The port Reaper is running on
- Whether accessed via localhost or network IP
- Which subdirectory the files are placed in

## Key Features

1. **Reactive UI**: Lit's reactive properties automatically update the interface
2. **Responsive Design**: Works on desktop, tablet, and mobile devices
3. **Visual Feedback**: Active states for play/pause/record with animations
4. **Confirmation Dialogs**: Prevents accidental undo operations
5. **Easy Theming**: CSS custom properties for quick customization
6. **Fast Development**: Vite dev server with instant HMR
7. **Optimized Builds**: Production-ready bundles for deployment

## Extending the Interface

### Adding New Controls

1. **Update types** in `src/types/index.ts`:
```typescript
export type CommandAction = 'play' | 'pause' | 'stop' | 'record' | 'save' | 'discard' | 'new';

export const REAPER_COMMANDS: Record<CommandAction, number> = {
    // ... existing commands
    new: 12345  // Replace with actual Reaper command ID
};
```

2. **Add state** in `src/components/reaper-remote.ts` (if stateful):
```typescript
@state()
private newActive = false;
```

3. **Add button** in the `render()` method:
```typescript
<control-button
    action="new"
    label="New Action"
    title="New Action"
    .active=${this.newActive}
    icon='<svg>...</svg>'>
</control-button>
```

4. **Update state logic** in `updateButtonState()` method:
```typescript
case 'new':
    this.newActive = !this.newActive;
    break;
```

### Creating New Components

Follow the `ControlButton` pattern:

1. Create file in `src/components/`
2. Use `@customElement` decorator
3. Define typed `@property` decorators for public API
4. Use `@state` for internal state
5. Import shared styles from `src/styles/shared.ts`
6. Emit custom events for parent communication
7. Add TypeScript declaration for global registry

### Finding Reaper Command IDs

1. Open Reaper
2. Go to **Actions** → **Show action list**
3. Search for the action you want
4. The command ID is shown in the **Command ID** column

### Customizing Appearance

Edit the CSS custom properties in `style.css`:
```css
:root {
    --primary-bg: #1a1a1a;
    --accent-color: #4a9eff;
    /* ... etc */
}
```

## Limitations

- **One-way Communication**: The interface sends commands but doesn't receive state updates from Reaper
- **No Transport Position**: Doesn't display current playback position or time
- **Basic Controls Only**: Limited to the six implemented transport/project controls
- **Client-side State**: Button states are visual only and don't reflect actual Reaper state

## Future Enhancement Ideas

- Add transport position display using Reaper's status endpoint
- Include volume/pan controls for tracks
- Add project/track selection
- Implement keyboard shortcuts
- Add WebSocket support for real-time state updates
- Include marker navigation
- Add FX parameter controls

## Development Notes

### Development Workflow

1. **Install dependencies**:
```bash
pnpm install
```

2. **Run development server** (with HMR):
```bash
pnpm run dev
```

3. **Build for production**:
```bash
pnpm run build
```

4. **Preview production build**:
```bash
pnpm run preview
```

### Deployment to Reaper

After building for production:
1. Copy files from `dist/` directory to Reaper's `reaper_www_root` directory
2. Ensure Reaper has web interface enabled (Preferences → Control/OSC/web)
3. Access via `http://localhost:8080/` (or your configured port)

### Browser Compatibility
Uses modern TypeScript/JavaScript features:
- TypeScript with decorators (`experimentalDecorators`)
- ES2022 features (ES modules, classes, arrow functions, template literals)
- Lit directives and templating
- Fetch API
- Web Components (Custom Elements, Shadow DOM)
- CSS custom properties

TypeScript is compiled to JavaScript by Vite during the build process. All features are supported in modern browsers (Chrome/Edge/Firefox/Safari). Internet Explorer is not supported.

## Architecture Benefits

The refactored architecture provides:

1. **Type Safety**: TypeScript catches errors at compile time
2. **Modularity**: Each component/service has a single responsibility
3. **Reusability**: `ControlButton` can be reused for any new controls
4. **Maintainability**: Clear separation between UI, state, and API logic
5. **Testability**: Services and components can be tested independently
6. **Scalability**: Easy to add new features without modifying existing code
7. **Developer Experience**: IntelliSense, auto-completion, and type checking

## Development Rules

### Testing Changes
**IMPORTANT**: Whenever you make changes to the codebase, you MUST verify them using Chrome DevTools MCP:

1. Ensure the dev server is running (`pnpm run dev`)
2. Navigate to the application in Chrome DevTools MCP
3. Take a snapshot to verify UI elements are present
4. Check console messages for errors
5. Test relevant functionality by clicking buttons/interacting with UI
6. Verify network requests are being sent correctly
7. Take screenshots to confirm visual changes

This ensures all changes are working correctly in the browser before considering the task complete.
